package software.amazon.smithy.java.server.example;

import software.amazon.smithy.java.core.endpoint.Endpoint;
import software.amazon.smithy.java.example.callbacks.model.DeleteCallbackInput;
import software.amazon.smithy.java.example.callbacks.model.DeleteCallbackOutput;
import software.amazon.smithy.java.example.callbacks.model.NotifyCompletedInput;
import software.amazon.smithy.java.example.callbacks.model.NotifyCompletedOutput;
import software.amazon.smithy.java.example.callbacks.service.CoffeeShopCallbacks;
import software.amazon.smithy.java.server.RequestContext;
import software.amazon.smithy.java.server.Server;
import software.amazon.smithy.utils.SmithyGenerated;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

// Helper utilities for common patterns when implementing
// a local service like CoffeeCallbacks entirely in-memory.
// Would be generated by `java-server-codegen` given the right
// smithy-build.json configuration indicating the service will be used in this way.
// "Proper" remote services might benefit from some of the code generation
// for resources as well, although they are generally more useful for in-memory services.
@SmithyGenerated // Not actually but intended to be :)
public class CoffeeCallbacksInMemoryServer implements AutoCloseable {

    private Server server;
    private Endpoint endpoint = LocalService.defaultInMemoryEndpoint("coffeeshopcallbacks");

    private final ConcurrentHashMap<String, CompletedCallback> completedCallbacksById = new ConcurrentHashMap<>();

    // TODO: Ideally you would start a single Server for all Java-based local services instead.
    // That would require some kind of SPI registration.
    public void start() {
        server = Server.builder("smithy-java-netty-server")
                .endpoints(endpoint)
                .addService(
                        CoffeeShopCallbacks.builder()
                                .addDeleteCallbackOperation(this::deleteCallbackOperation)
                                .addNotifyCompletedOperation(this::notifyCompletedOperation)
                                .build()
                )
                .build();
        server.start();
    }

    public void shutdown() {
        server.shutdown();
    }

    @Override
    public void close() throws Exception {
        shutdown();
    }

    public Endpoint getEndpoint() {
        return endpoint;
    }

    // Generated for the CompletedCallback resource
    //
    // If there is only operation, these kinds of interfaces can be used as a @FunctionalInterface.
    // Adding more operations would break that, but new models are generally a breaking change to servers anyway.
    // A CoffeeShop client can talk to a new version of the CoffeeShop service
    // that uses a newer version of CoffeeShopCallbacks,
    // without the client code using that new model itself.
    // If the CoffeeShop service tries to invoke a new CoffeeShopCallbacks operation,
    // the protocol code will throw an exception.
    // It's important for that to only happen if the client opts-in through different input somehow.
    interface CompletedCallback {
        CompletableFuture<NotifyCompletedOutput> notifyCompleted(NotifyCompletedInput input, RequestContext context);
    }

    public String createCallback(CompletedCallback callback) {
        // TODO: This should be configurable somehow, in many cases just an incrementing int would be fine.
        var id = UUID.randomUUID().toString();
        completedCallbacksById.put(id, callback);
        return id;
    }

    public CompletableFuture<NotifyCompletedOutput> notifyCompletedOperation(NotifyCompletedInput input, RequestContext context) {
        var callback = completedCallbacksById.get(input.callbackId());
        return callback.notifyCompleted(input, context);
    }

    public CompletableFuture<DeleteCallbackOutput> deleteCallbackOperation(DeleteCallbackInput input, RequestContext context) {
        completedCallbacksById.remove(input.callbackId());
        return CompletableFuture.completedFuture(DeleteCallbackOutput.builder().build());
    }
}
