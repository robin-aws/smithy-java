package software.amazon.smithy.java.server.example;

import software.amazon.smithy.java.core.endpoint.Endpoint;
import software.amazon.smithy.java.example.callbacks.model.NotifyCompletedInput;
import software.amazon.smithy.java.example.callbacks.model.NotifyCompletedOutput;
import software.amazon.smithy.java.example.callbacks.service.CoffeeShopCallbacks;
import software.amazon.smithy.java.example.model.ResolvedEndpoint;
import software.amazon.smithy.java.server.RequestContext;
import software.amazon.smithy.java.server.Server;
import software.amazon.smithy.utils.SmithyGenerated;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

// Helper utilities for common patterns when implementing
// a local service like CoffeeCallbacks.
// Would be generated by `java-server-codegen` given the right
// smithy-build.json configuration indicating the service will be used in this way.
// "Proper" remote services might benefit from some of the code generation
// for resources as well.
@SmithyGenerated // Not actually but intended to be :)
public class CoffeeCallbacks {

    private static Server SERVER;
    private static ResolvedEndpoint ENDPOINT = ResolvedEndpoint.builder()
            .url("http://localhost/")
            .channelUrl("unix:%s/.aws/localservices/coffeeshopcallbacks/%s".formatted(
                    System.getProperty("user.home"), ProcessHandle.current().pid()))
            .build();

    // This should only be emitted for the right @localService and smithy-build.json configuration.
    // TODO: Ideally you would start a single Server for all Java-based local services instead.
    // That would require some kind of SPI registration.
    public synchronized static void start() {
        if (SERVER == null) {
            Server server = Server.builder("smithy-java-netty-server")
                    .endpoints(ResolvedEndpointResolver.endpoint(ENDPOINT))
                    .addService(
                            CoffeeShopCallbacks.builder()
                                    .addNotifyCompletedOperation(CoffeeCallbacks::singleUseNotifyCompletedOperation)
                                    .build()
                    )
                    .build();
            server.start();
        }
    }

    public synchronized static void shutdown() {
        if (SERVER != null) {
            SERVER.shutdown();
            SERVER = null;
        }
    }

    public static ResolvedEndpoint getEndpoint() {
        // TODO: Cheating a bit, but it should be reasonable for the server
        // to already be started for you.
        start();
        return ENDPOINT;
    }

    // Generated for the CompletedCallback resource
    @SmithyGenerated
    interface CompletedCallback {
        // If there is only operation, can be used as a @FunctionalInterface.
        // Adding more operations would break that, but new models are generally a breaking change to servers anyway.
        // A CoffeeShop client can talk to a new version of the CoffeeShop service
        // that uses a newer version of CoffeeShopCallbacks,
        // without the client code using that new model itself.
        // If the CoffeeShop service tries to invoke a new CoffeeShopCallbacks operation,
        // the protocol code will throw an exception.
        // It's important for that to only happen if the client opts-in through different input somehow.
        CompletableFuture<NotifyCompletedOutput> notifyCompleted(NotifyCompletedInput input, RequestContext context);
    }

    public static CompletableFuture<NotifyCompletedOutput> singleUseNotifyCompletedOperation(NotifyCompletedInput input, RequestContext context) {
        var callback = completedCallbacksById.remove(input.callbackId());
        return callback.notifyCompleted(input, context);
    }

    public static String createCompletedCallback(String id, CompletedCallback callback) {
        completedCallbacksById.put(id, callback);
        return id;
    }

    private static final ConcurrentHashMap<String, CompletedCallback> completedCallbacksById = new ConcurrentHashMap<>();
}
